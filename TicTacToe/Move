class Move
	attr_accessor :move
	def initialize()
		@move = move
	end	

	def human_move(board, player)
		get_human_input
		if board.valid_move?(board.data, @move)
			update_move(board, @move, player)
		else
			puts "Not a valid move. Please choose a free space on the board."
	  	 	human_move(board, player)
		end
	end

	def get_human_input
		puts 'Enter position to play'
		@move = gets.to_i
	end

	def computer_move(board, player)
		determine_play_method(board, player)
		update_move(board, @move, player)
	end

	def determine_play_method(board, player)
		if board.available_spaces(board.data).count == 9
			random_start_play
		else
			negamax_calculated_play(board, player)
		end
	end

	def random_start_play
		@move = [1,3,5,7,9].sample
	end

	def negamax_calculated_play(board, player)
		negamax(board, player, 1)
		return @move
	end

	def update_move(board, move, player)
		puts "#{player} plays in space #{move}"
     	board.update(board.data, move, player)
    end
	
	def negamax(board, player, depth)
		opponent = opponent(player)
    	if board.game_over?(board.data, player)
      		return score(board, player, opponent, depth)
    	else
      		best_rank = -999
      		board.available_spaces(board.data).each do |space|
        	board.update(board.data, space + 1, player)
        	rank = -negamax(board, opponent, depth + 1 )
       		board.un_update(board.data, space + 1)
       			if rank > best_rank
         			best_rank = rank
         			@move = space + 1 if depth == 1
				end
     		end
     		return best_rank
		end
	end

 	def opponent(marker)
      	marker == "X" ? "O" : "X"
    end

    def score(board, player, opponent, depth)
		if board.win?(board.data, player) 
			return 100 - depth
		elsif board.win?(board.data, opponent)
		    return -(100 - depth)
		else
		    return 0
		end
	end
end
